Please propose exactly {{ num_projects }} diverse projects for the agent to work on, along with names for each project repo.
Format your output as a list of exactly {{ num_projects }} projects, each in the following format:

Project 1:
<proposed_project>...</proposed_project>
<repo_name>...</repo_name>
<programming_language>...</programming_language>
<constraints>...</constraints>

Project 2:
<proposed_project>...</proposed_project>
<repo_name>...</repo_name>
<programming_language>...</programming_language>
<constraints>...</constraints>

... (continue for all projects)

Each proposed project should be **algorithmically complex and computationally challenging** with the following characteristics:
- **Algorithm-heavy**: Must implement complex algorithms, data structures, or computational methods from scratch
- **Core logic implementation**: Cannot be solved by simply using existing libraries - requires substantial custom logic
- **Multi-component architecture**: Systems with multiple interacting components and complex state management
- **Non-trivial data processing**: Complex parsing, transformation, analysis, or generation of data
- **Custom protocols/formats**: Implementation of interpreters, compilers, parsers, or custom communication protocols

**INTERFACE REQUIREMENT:**
- **Command-line interface only**: All projects must be operated via CLI with command-line arguments, flags, and text-based output
- **No GUI components**: Projects must not include graphical user interfaces, web interfaces, or visual components
- **Text-based interaction**: All input/output should be through files, command-line parameters, or terminal text
- **Scriptable and automatable**: CLI design should enable easy automation and testing

**LIBRARY CONSTRAINTS REQUIREMENT:**
Each project must include specific constraints in the <constraints> section about which libraries/frameworks cannot be used. These constraints should force developers to implement fundamental algorithms from scratch rather than using existing solutions. Examples:
- Computer algebra systems: "Cannot use numpy, scipy, or sympy"
- Machine learning: "Cannot use TensorFlow, PyTorch, or scikit-learn"
- Cryptography: "Cannot use existing crypto libraries like cryptography or pycrypto"
- Database engines: "Cannot use SQLite, PostgreSQL, or any existing database libraries"

**CLEAR SPECIFICATION REQUIREMENT:**
Each project must be clearly defined with specific, concrete requirements that enable comprehensive test case development:
- **Specific input/output formats**: Clearly define expected inputs and outputs with exact formats
- **Concrete functionality**: Detailed description of what the system should do with specific behaviors
- **Measurable performance criteria**: Include specific performance requirements, benchmarks, or constraints
- **Testable behavior**: Well-defined behaviors that can be verified through unit tests and integration tests
- **Unambiguous success criteria**: Clear definition of what constitutes a successful implementation
- **Edge case handling**: Explicit requirements for error conditions, boundary cases, and failure modes

All projects should use Python as the programming language. Projects should focus on implementing sophisticated computational systems with well-defined, testable specifications accessible only through CLI.

**DIVERSITY REQUIREMENT:**
Ensure maximum diversity across the 50 projects by:
- **Distributing across complexity areas**: Include projects from each of the complexity areas listed above, not clustering around just a few areas
- **Varying system types**: Mix low-level systems, high-level algorithms, and mid-level tools
- **Different problem domains**: Include projects spanning various domains
- **Balanced complexity focus**: Some projects should focus on data structures, others on algorithms, others on system design, others on mathematical computation
- **Avoid repetition**: Each project should address distinctly different computational challenges and use cases

**AVOID** (these are too simple, too vague, or inappropriate):
- Basic CRUD applications or simple data management
- Standard desktop/web apps without algorithmic complexity  
- File processing tools using standard libraries
- Simple wrappers around existing libraries
- Projects primarily focused on UI with minimal logic
- Basic automation scripts or simple utilities
- Vague or ambiguous project descriptions that don't specify concrete requirements
- Any projects requiring GUI, web interfaces, or visual components such as computer graphics related tasks
- Any projects requiring non-textual elements such as images or files as input and output
- Any projects aiming at some open-ended problems and implementation correctness cannot be easily evaluated  

Here are some generated cases:
{"project_description": "Create a compiler for a custom functional programming language with lexical analysis, recursive descent parsing, type inference, lambda calculus evaluation, and code generation to bytecode. Include pattern matching, higher-order functions, closures, and an interpreter with garbage collection and tail call optimization.", "repo_name": "functional-lang-compiler", "programming_language": "Python", "constraints": "Cannot use any existing parser generators (e.g., PLY, Lark, ANTLR) or compiler construction frameworks. Must implement the lexical analyzer, recursive descent parser, type inference system, and bytecode generator/interpreter from scratch. Only basic string and file I/O operations are permitted."}
{"project_description": "Create a computer algebra system implementing symbolic mathematics, polynomial arithmetic, and calculus operations. Must support expression parsing, algebraic simplification, differentiation, integration, and equation solving. Include matrix operations, linear algebra, and numerical methods for root finding. Solve systems of equations with 10+ variables and integrate complex functions symbolically. Input: Mathematical expressions in LaTeX format. Output: Simplified expressions with step-by-step solutions and numerical approximations where applicable.", "repo_name": "computer-algebra-system", "programming_language": "Python", "constraints": "Cannot use any existing symbolic mathematics libraries (e.g., SymPy) or numerical/scientific computing libraries (e.g., NumPy, SciPy). Must implement all expression parsing (including LaTeX), symbolic manipulation (simplification, differentiation, integration), polynomial arithmetic, and matrix operations from scratch."}
{"project_description": "Create a Git-like version control system with support for repositories, commits, branches, merging, and diff algorithms. Must implement object storage with SHA-1 hashing, three-way merge algorithm, conflict resolution, branch management, and repository compression. The system should handle binary files, large repositories (>10MB), and maintain complete history integrity. CLI interface with commands for init, add, commit, branch, merge, log, diff, and status operations matching Git's interface.", "repo_name": "version-control-system", "programming_language": "Python", "constraints": "Cannot use existing VCS libraries (e.g., GitPython, dulwich). Must implement all version control algorithms, diff algorithms, and merge strategies from scratch without using version control frameworks. Only basic file system operations and hashing allowed."}
{"project_description": "Build a process scheduler simulator implementing multiple scheduling algorithms (FCFS, SJF, Round Robin, Priority, Multilevel Queue) with preemption support. Must simulate process creation, CPU burst times, I/O operations, context switching overhead, and memory management. The simulator should generate detailed statistics on turnaround time, waiting time, CPU utilization, and throughput for comparison between algorithms. CLI interface for loading process workloads, selecting scheduling algorithms, and outputting performance metrics.", "repo_name": "process-scheduler-simulator", "programming_language": "Python", "constraints": "Cannot use existing simulation frameworks or scheduling libraries. Must implement all scheduling algorithms, process state management, and simulation logic from scratch without using operating system libraries or simulation frameworks."}
{"project_description": "Create a file system simulator supporting ext4-like features including inodes, directory structures, file allocation, journaling, and defragmentation. Must implement block allocation algorithms, metadata management, crash recovery, and file system consistency checks. The simulator should handle file systems up to 1GB size and support concurrent file operations. CLI interface for mounting/unmounting, file operations (create, read, write, delete), directory navigation, and file system maintenance commands.", "repo_name": "filesystem-simulator", "programming_language": "Python", "constraints": "Cannot use existing file system libraries or implementations. Must implement all file system algorithms, block management, and metadata structures from scratch without using file system frameworks. Only basic file I/O for the underlying storage file allowed."}
{"project_description": "Implement a quantum computing simulator supporting quantum gates, quantum circuits, and quantum algorithms (Shor's, Grover's, Deutsch-Jozsa). Must implement quantum state representation, gate operations, measurement simulation, and quantum entanglement. The simulator should handle circuits with 20+ qubits and support quantum teleportation, superdense coding, and quantum error correction codes. CLI interface for circuit definition, quantum algorithm execution, and measurement analysis with quantum state visualization.", "repo_name": "quantum-computing-simulator", "programming_language": "Python", "constraints": "Cannot use existing quantum computing libraries (e.g., Qiskit, Cirq, PyQuil) or complex number libraries beyond basic Python complex type. Must implement all quantum mechanics calculations, gate operations, and quantum algorithms from scratch."}
{"project_description": "Implement a regular expression engine from scratch. The engine will take a regex pattern and a string as input and determine if the string matches the pattern. It must support concatenation, union (`|`), Kleene star (`*`), and grouping (`()`). The implementation should first convert the regex pattern into a Non-deterministic Finite Automaton (NFA) using Thompson's construction, then simulate the NFA to match the string. For performance, implement the conversion of the NFA to a Deterministic Finite Automaton (DFA) and use the resulting DFA for matching. CLI should allow specifying a pattern, an input file, and an option to print the generated NFA/DFA structure in a text format.", "repo_name": "regex-engine", "programming_language": "Python", "constraints": "Cannot use Python's built-in `re` module or any other third-party regex libraries. All logic for parsing the regex pattern, constructing the NFA, converting to a DFA, and performing the match must be implemented from scratch."}
{"project_description": "Develop a disk defragmenter simulator. The program will model a disk as a block array and simulate file fragmentation over time. It should be able to read a \"scenario\" file describing a sequence of file creations, extensions, and deletions. After simulating fragmentation, it must implement a defragmentation algorithm that relocates file blocks to make them contiguous, minimizing data movement. The CLI will run the simulation and then the defragmentation, reporting statistics like fragmentation percentage before and after, and the number of blocks moved.", "repo_name": "defragmenter-simulator", "programming_language": "Python", "constraints": "Cannot use any existing simulation frameworks. The representation of the disk, files, and free space (e.g., using a bitmap or a free list), and the entire defragmentation logic must be custom-built."}
{"project_description": "Implement a code transpiler that converts a subset of Python code to C++. The transpiler must parse Python code into an AST, transform the Python AST into a structure that maps to C++ concepts, and then generate readable C++ code from this intermediate structure. It should handle variables, basic arithmetic, conditional statements (`if/else`), loops (`for`, `while`), and function definitions. The CLI will take a Python file and produce a corresponding `.js` file.", "repo_name": "python-to-js-transpiler", "programming_language": "Python", "constraints": "Python's `ast` module is allowed for parsing the source code. However, the AST transformation logic and the entire C++ code generator must be built from scratch. No third-party transpiler tools or code generation libraries can be used."}
{"project_description": "Implement a distributed task queue using a broker-based architecture (like Celery). It requires three components: a client to submit tasks, a broker to mediate messages, and workers to execute tasks. The broker must be implemented from scratch, receiving task messages and queueing them. Workers will connect to the broker, fetch tasks, execute them, and report results. The system must support reliable messaging (at-least-once delivery) and allow multiple workers to consume from the same queue. Communication should use a custom TCP protocol.", "repo_name": "distributed-task-queue", "programming_language": "Python", "constraints": "Cannot use message queue systems like RabbitMQ, Redis, or ZeroMQ. The entire broker, client library, and worker logic, including the network protocol for communication, must be implemented from scratch using basic sockets."}
{"project_description": "Develop a Markdown parser that supports the CommonMark specification, including extensions like tables and footnotes. The parser should not use regular expressions for its core logic but instead be based on a line-by-line parsing approach with state management to handle block-level structures (paragraphs, headers, lists, blockquotes) and inline formatting (bold, italic, code). It must produce an HTML output. The CLI should take a Markdown file and output the corresponding HTML.", "repo_name": "markdown-parser", "programming_language": "Python", "constraints": "Cannot use any existing Markdown or regex libraries (`markdown`, `mistune`, `re`). The entire parsing logic, state machine for blocks, and inline parsing must be implemented from scratch, following the CommonMark spec's detailed parsing rules."}
{"project_description": "Develop a Bayesian network library for probabilistic reasoning. The library should allow defining a directed acyclic graph (DAG) representing dependencies between random variables, along with their conditional probability tables (CPTs). Implement an inference algorithm, such as variable elimination, to compute the probability of a query variable given some evidence. The CLI will take a network definition file (e.g., in JSON), evidence variables, and a query variable, and output the resulting probability distribution.", "repo_name": "bayesian-network-library", "programming_language": "Python", "constraints": "Cannot use any probabilistic programming or graphical model libraries (`pgmpy`, `pymc`). The graph representation, CPT data structures, and the entire variable elimination algorithm (including factor multiplication and summation) must be implemented from scratch."}
{"project_description": "Develop a customizable event-driven simulation engine for discrete-event systems. The engine should support user-defined entities, scheduled events, priority queues, and resource contention. Simulate environments such as network packet flows, job shops, or traffic lights, with input scenario files. CLI options must allow scenario definition, step-through mode, and statistics output (e.g., throughput, latency).", "repo_name": "event-simulation-engine", "programming_language": "Python", "constraints": "Cannot use any simulation frameworks (e.g., SimPy, Simula). Priority queues, event scheduling, and resource management must be implemented from scratch."}
{"project_description": "Build a (text-based) event sourcing framework and sample accounting application. Framework records all state changes as immutable events, reconstructs state via event replay, supports event upcasting, and allows querying event log history. CLI: create accounts, post transactions, query state/events, simulate crash recovery.", "repo_name": "event-sourcing-framework", "programming_language": "Python", "constraints": "Cannot use event sourcing or CQRS/ES frameworks. All event log, replay, and upcasting logic must be implemented from scratch."}
{"project_description": "Develop an expert system with a custom forward-chaining inference engine. The system will have a knowledge base of rules (in `IF-THEN` format) and a fact base. The inference engine will repeatedly scan the rules and fire any whose conditions are met by the current facts, adding new facts to the fact base until no more rules can be fired. The CLI will load a rule file and an initial set of facts, run the inference engine, and print the final set of deduced facts.", "repo_name": "forward-chaining-expert-system", "programming_language": "Python", "constraints": "Cannot use any existing rule engines or expert system shells like `Pyke` or `CLIPS`. The rule parser, the data structures for facts and rules, and the entire forward-chaining inference algorithm (the match-resolve-act cycle) must be implemented from scratch."}
{"project_description": "Implement a Lisp interpreter (Scheme dialect) that supports lexical scoping, first-class functions, macros, and tail-call optimization. The interpreter must parse S-expressions, manage an environment model for variable bindings, and evaluate expressions recursively. It should support core features like `define`, `lambda`, `if`, `quote`, `set!`, and `let`. Include a garbage collector (mark-and-sweep) to manage memory for Lisp objects. The CLI should offer a REPL and a way to execute `.scm` script files.", "repo_name": "lisp-interpreter", "programming_language": "Python", "constraints": "Cannot use any parsing libraries like `PLY` or `Lark`. The entire S-expression parser, environment model, evaluation loop, and garbage collector must be implemented from scratch. No external libraries for functional programming concepts are allowed."}
{"project_description": "Develop a spreadsheet application that runs entirely in the terminal. The application must support a grid of cells, cell addressing (e.g., `A1`, `B2`), and formulas (e.g., `=A1+B2*5`). Implement a formula parser and an evaluation engine that correctly handles operator precedence and cell dependencies. The core challenge is building a dependency graph to perform automatic recalculation when a cell's value changes. The interface will use keyboard commands for navigation and cell editing within the terminal.", "repo_name": "terminal-spreadsheet", "programming_language": "Python", "constraints": "Cannot use parsing libraries for formulas. The expression parser (e.g., shunting-yard algorithm), dependency graph, and evaluation logic must be custom-built. Libraries like `curses` for terminal UI are permitted, but no core logic can be offloaded."}
You must generate different projects from the above ones.

Generate the projects as you are required. You are encouraged to be more creative and propose some projects that are not among the recommendation types. 

Do not involve file iteraction. All input and output should be with command line.
